import numpy as np
import cv2

# ...

def distance_to_camera(known_width, focal_length, measured_width):
    return (known_width * focal_length) / measured_width

# Predefined values for distance estimation
KNOWN_WIDTH = 12.0  # inches, adjust this based on the actual size of your target
FOCAL_LENGTH = 450  # pixels, a rough initial estimate (you should calibrate this value)

def runPipeline(image, llrobot):
    img_hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)

    # Define the lower and upper bounds for the purple color
    purple_lower = (120, 50, 50)
    purple_upper = (160, 255, 255)

    img_threshold = cv2.inRange(img_hsv, purple_lower, purple_upper)

    contours, _ = cv2.findContours(img_threshold, 
    cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    largestContour = np.array([[]])
    llpython = [0, 0, 0, 0, 0, 0, 0, 0]

    if len(contours) > 0:
        largestContour = max(contours, key=cv2.contourArea)
        x, y, w, h = cv2.boundingRect(largestContour)

        # Calculate the distance to the object
        distance = distance_to_camera(KNOWN_WIDTH, FOCAL_LENGTH, w)

        # Filter by size and distance
        if cv2.contourArea(largestContour) > 5000 and distance < 200:  # Adjust these values as needed
            cv2.drawContours(image, contours, -1, 255, 2)
            cv2.rectangle(image, (x, y), (x+w, y+h), (0, 255, 255), 2)
            llpython = [1, x, y, w, h, 9, 8, 7]

    return largestContour, image, llpython